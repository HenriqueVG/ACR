# -*- coding: utf-8 -*-
"""novelty_functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/iranroman/musicinformationretrieval.com/blob/gh-pages/novelty_functions.ipynb
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy, scipy, matplotlib.pyplot as plt, IPython.display as ipd
import librosa, librosa.display
import stanford_mir; stanford_mir.init()

"""[&larr; Back to Index](index.html)

# Novelty Functions

To detect note onsets, we want to locate sudden changes in the audio signal that mark the beginning of transient regions. Often, an increase in the signal's amplitude envelope will denote an onset candidate. However, that is not always the case, for notes can change from one pitch to another without changing amplitude, e.g. a violin playing slurred notes.

**Novelty functions** are functions which denote local changes in signal properties such as energy or spectral content. We will look at two novelty functions:

1. Energy-based novelty functions (FMP, p. 306)
2. Spectral-based novelty functions (FMP, p. 309)

## Energy-based Novelty Functions

Playing a note often coincides with a sudden increase in signal energy. To detect this sudden increase, we will compute an **energy novelty function** (FMP, p. 307):

1. Compute the short-time energy in the signal.
2. Compute the first-order difference in the energy.
3. Half-wave rectify the first-order difference.

First, load an audio file into the NumPy array `x` and sampling rate `sr`.
"""

x, sr = librosa.load('audio/simple_loop.wav')
print(x.shape, sr)

"""Plot the signal:"""

plt.figure(figsize=(14, 5))
librosa.display.waveplot(x, sr)

"""Listen:"""

ipd.Audio(x, rate=sr)

"""### RMS Energy

[`librosa.feature.rmse`](http://librosa.github.io/librosa/generated/librosa.feature.rmse.html#librosa.feature.rmse) returns the root-mean-square (RMS) energy for each frame of audio. We will compute the RMS energy as well as its first-order difference.
"""

hop_length = 512
frame_length = 1024
rmse = librosa.feature.rmse(x, frame_length=frame_length, hop_length=hop_length).flatten()
rmse_diff = numpy.zeros_like(rmse)
rmse_diff[1:] = numpy.diff(rmse)

print(rmse.shape)
print(rmse_diff.shape)

"""To obtain an energy novelty function, we perform **half-wave rectification** (FMP, p. 307) on `rmse_diff`, i.e. any negative values are set to zero. Equivalently, we can apply the function $\max(0, x)$:"""

energy_novelty = numpy.max([numpy.zeros_like(rmse_diff), rmse_diff], axis=0)

"""Plot all three functions together:"""

frames = numpy.arange(len(rmse))
t = librosa.frames_to_time(frames, sr=sr)

plt.figure(figsize=(15, 6))
plt.plot(t, rmse, 'b--', t, rmse_diff, 'g--^', t, energy_novelty, 'r-')
plt.xlim(0, t.max())
plt.xlabel('Time (sec)')
plt.legend(('RMSE', 'delta RMSE', 'energy novelty'))

"## Log Energy


log_rmse = numpy.log1p(10*rmse)
log_rmse_diff = numpy.zeros_like(log_rmse)
log_rmse_diff[1:] = numpy.diff(log_rmse)

log_energy_novelty = numpy.max([numpy.zeros_like(log_rmse_diff), log_rmse_diff], axis=0)

plt.figure(figsize=(15, 6))
plt.plot(t, log_rmse, 'b--', t, log_rmse_diff, 'g--^', t, log_energy_novelty, 'r-')
plt.xlim(0, t.max())
plt.xlabel('Time (sec)')
plt.legend(('log RMSE', 'delta log RMSE', 'log energy novelty'))


"""## Spectral-based Novelty Functions

There are two problems with the energy novelty function:

1. It is sensitive to energy fluctuations belonging to the same note.
2. It is not sensitive to spectral fluctuations between notes where amplitude remains the same.

"""

sr = 22050
def generate_tone(midi):
    T = 0.5
    t = numpy.linspace(0, T, int(T*sr), endpoint=False)
    f = librosa.midi_to_hz(midi)
    return numpy.sin(2*numpy.pi*f*t)

x = numpy.concatenate([generate_tone(midi) for midi in [48, 52, 55, 60, 64, 67, 72, 76, 79, 84]])


hop_length = 512
frame_length = 1024
rmse = librosa.feature.rmse(x, frame_length=frame_length, hop_length=hop_length).flatten()
rmse_diff = numpy.zeros_like(rmse)
rmse_diff[1:] = numpy.diff(rmse)

energy_novelty = numpy.max([numpy.zeros_like(rmse_diff), rmse_diff], axis=0)

frames = numpy.arange(len(rmse))
t = librosa.frames_to_time(frames, sr=sr)

plt.figure(figsize=(15, 4))
plt.plot(t, rmse, 'b--', t, rmse_diff, 'g--^', t, energy_novelty, 'r-')
plt.xlim(0, t.max())
plt.xlabel('Time (sec)')
plt.legend(('RMSE', 'delta RMSE', 'energy novelty'))

"""
1.  Compute the log-amplitude spectrogram.
2.  Within each frequency bin, $k$, compute the energy novelty function as shown earlier, i.e. (a) first-order difference, and (b) half-wave rectification.
3.  Sum across all frequency bins, $k$.

"""

spectral_novelty = librosa.onset.onset_strength(x, sr=sr)

frames = numpy.arange(len(spectral_novelty))
t = librosa.frames_to_time(frames, sr=sr)

plt.figure(figsize=(15, 4))
plt.plot(t, spectral_novelty, 'r-')
plt.xlim(0, t.max())
plt.xlabel('Time (sec)')
plt.legend(('Spectral Novelty',))


